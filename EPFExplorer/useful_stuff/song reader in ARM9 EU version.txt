0x214C82C    ldr 	load next int in the song data
0x214C82E    movs 	load zero into r0
0x214C830    mvns       logical negate zero so that it's 0xFFFFFFFF
0x214C832    cmp	compare the next int to 0xFFFFFFFF

if (equal to 0xFFFFFFFF)	//probably signifies the end of that particular part of the pattern
	branch to 0x214CEB4

else if (not equal to 0xFFFFFFFF)
	branch to 0x214C838


0x214C838      move r1 to r0
0x214C83A      add 9 to r0
0x214C83C      load the value at (r5 + r0) and store it in r0

some other stuff, I think this might only be important for DS runtime, then

0x214C840 	set r0 to (the address of the unknown bin section + the int we loaded from the song data)


LATER, WHEN IT ACTUALLY GOES TO THAT ADDRESS...

0x0214C86A	load byte at the address
0x0214C86E	tst it against the value in r7 (0x80 every time or not?)	(essentially a logical AND but doesn't store the result, only updates flags)
0x0214C86E 	if the AND value was equal to zero (aka, if the highest bit wasn't set) branch to 0x214C87C

if (the bit WAS set, therefore the zero flag is unset):
go to the address 8 ahead
increment that address for later (so that it's 9 ahead next time we go to it)

load a byte from the address into r0 (the 8 ahead one)

else if (the bit WASN'T set, therefore the zero flag is set):

0x0214C87C	move 0 into r0

explanation of what just happened:

If the high bit is unset, just use that byte in r0
But if the high bit was set, go to an address a certain number of bytes ahead, and put the byte at THAT address in R0 instead.
This does seem a lot like XM music instructions with the whole 'high bit' thing

and now both paths rejoin:

0x0214C87E shift r0 left by 0x18 bits (so that it's in the highest byte instead of the lowest one)

0x0214C880 but keep a copy of its original form in r2

0x0214C882 compare 1 to r7 (0x80)

if r7 is lower than or equal to 1, branch to 0x0214C88A		--essentially, this will be true once it has tested all the bits in the byte

otherwise...

0x0214C886 shift r7 right by one
0x0214C888 branch to 0x214C892





0x0214C892 load the start address of the pattern back into r0
0x0214C894 load the byte at that address into r0
0x0214C896 test the byte against r7 (now 0x40)

if (the second bit in the byte was set)
	{
	keep going to 0x0214C89A
	}
else
	{
	branch to 0x0214C8A6
	}


0x0214C89A go 1 byte ahead and load that byte into r0
branch to 0x0214C8A8

shift it all the way left
shift it all the way right again and store it in r3

the interesting thing is... it's STILL going 8,9,10 bytes ahead etc to get these values

I think I see how this works now.

the vaguely compression bytes for each instruction are kept all together in the first 8 bytes of the pattern, and the actual parameters that they reference are stored later on in the body of the pattern? maybe?



it does this bitwise checking for 0x80, 0x40, 0x20, 0x10, 0x08, 0x04

0x04 and 0x02 overwrote the values that were stored in the registers for 0x80 and 0x40!


finally, at 0x0214C8C2, r7 is 1. So it branches to 0x214C8D0

How did it get 0x11 in r3???? I don't see where it got it from...




for the DFDD near the start of the EPF main theme...

C6 has 31
B5 has ?
8C has 2E
03 has ?
F0 has 22
84 has 61
21 also has 61

